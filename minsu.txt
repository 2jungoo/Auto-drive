#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy
from sensor_msgs.msg import CompressedImage, LaserScan
from geometry_msgs.msg import Twist
import cv2
import numpy as np
import threading
import time
import socket
import math
import json
from http.server import BaseHTTPRequestHandler, HTTPServer
from enum import Enum

# QOS í”„ë¡œíŒŒì¼ ì„¤ì •
qos_profile = QoSProfile(depth=10)
qos_profile.reliability = ReliabilityPolicy.BEST_EFFORT

# ì£¼í–‰ ëª¨ë“œë¥¼ ì •ì˜í•˜ëŠ” ì—´ê±°í˜•
class DriveMode(Enum):
    LANE_FOLLOWING = "LANE_FOLLOWING"
    OBSTACLE_AVOIDANCE = "OBSTACLE_AVOIDANCE"
    INITIALIZING = "INITIALIZING"

# ì›¹ ëŒ€ì‹œë³´ë“œë¥¼ ìœ„í•œ HTTP ì„œë²„ í•¸ë“¤ëŸ¬ (ê¸°ëŠ¥ ë³€ê²½ ì—†ìŒ)
class WebViewer(BaseHTTPRequestHandler):
    def __init__(self, autoracer_node, *args, **kwargs):
        self.autoracer = autoracer_node
        super().__init__(*args, **kwargs)

    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            html = """
            <html>
            <head>
                <title>ğŸ Autoracer Ultimate - Advanced Obstacle Avoidance & Lane Following</title>
                <style>
                    body { font-family: 'Segoe UI', Arial, sans-serif; background-color: #121212; color: #e0e0e0; margin: 0; padding: 20px; }
                    .container { display: flex; gap: 20px; max-width: 1600px; margin: auto; }
                    .panel { background: #1e1e1e; border-radius: 12px; padding: 20px; border: 1px solid #333; }
                    h1, h3 { color: #00bcd4; text-align: center; }
                    .metric { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #333; }
                    .metric span:last-child { font-weight: bold; color: #81c784; }
                </style>
            </head>
            <body>
                <h1>ğŸ† Autoracer Ultimate Edition ğŸ†</h1>
                <div class="container">
                    <div class="panel" style="flex: 3;">
                        <h3>ğŸ“¹ Live Feed</h3>
                        <img src="/stream.mjpg" style="width: 100%; border-radius: 8px;">
                    </div>
                    <div class="panel" style="flex: 1;">
                        <h3>ğŸ“Š System Telemetry</h3>
                        <div id="stats-container"></div>
                    </div>
                </div>
                <script>
                setInterval(() => {
                    fetch('/stats')
                    .then(r => r.json())
                    .then(data => {
                        const container = document.getElementById('stats-container');
                        let content = '';
                        for (const [key, value] of Object.entries(data)) {
                            content += `<div class="metric"><span>${key.replace(/_/g, ' ')}:</span><span>${value}</span></div>`;
                        }
                        container.innerHTML = content;
                    }).catch(e => console.error('Stats error:', e));
                }, 500);
                </script>
            </body>
            </html>
            """
            self.wfile.write(html.encode())
            
        elif self.path == '/stream.mjpg':
            self.send_response(200)
            self.send_header('Content-Type', 'multipart/x-mixed-replace; boundary=frame')
            self.end_headers()
            try:
                while True:
                    frame = self.autoracer.get_processed_frame()
                    if frame is not None:
                        _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 90])
                        self.wfile.write(b'--frame\\r\\n')
                        self.send_header('Content-Type', 'image/jpeg')
                        self.send_header('Content-Length', str(len(buffer)))
                        self.end_headers()
                        self.wfile.write(buffer)
                        self.wfile.write(b'\\r\\n')
                    time.sleep(1/30) # 30 FPS
            except Exception as e:
                self.autoracer.get_logger().error(f'Streaming error: {e}')
                
        elif self.path == '/stats':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            stats = self.autoracer.get_stats()
            self.wfile.write(json.dumps(stats).encode())
        else:
            self.send_response(404)
            self.end_headers()

# ë©”ì¸ ììœ¨ì£¼í–‰ ë…¸ë“œ í´ë˜ìŠ¤
class Autoracer(Node):
    def __init__(self):
        super().__init__('Autoracer_Ultimate')
        
        # ì„¼ì„œ ë°ì´í„° ë° ë™ê¸°í™”
        self.current_image = None
        self.processed_frame = None
        self.lidar_data = None
        self.image_lock = threading.Lock()
        
        # ì£¼í–‰ ìƒíƒœ ê´€ë¦¬
        self.current_mode = DriveMode.INITIALIZING
        
        # ì œì–´ ë³€ìˆ˜
        self.current_speed, self.current_steering = 0.0, 0.0
        self.target_speed, self.target_steering = 0.0, 0.0
        
        # PID ì œì–´ ë³€ìˆ˜
        self.prev_error, self.integral_error = 0.0, 0.0
        
        # ì¥ì• ë¬¼ íšŒí”¼ ê´€ë ¨ ë³€ìˆ˜
        self.obstacle_avoidance_maneuver_active = False
        self.obstacle_avoidance_timer = None
        
        # ì„±ëŠ¥ ë° í†µê³„
        self.camera_fps = 0
        self.last_camera_time = time.time()
        
        # Bird's Eye View(BEV) ë³€í™˜ í–‰ë ¬
        self.bev_matrix, self.inv_bev_matrix = None, None
        self.setup_bev_transform()
        
        # ì°¨ì„  ì¶”ì¢… ì•ˆì •í™” ë³€ìˆ˜
        self.left_fit, self.right_fit = None, None
        self.lane_lost_counter = 0

        # ROS2 í†µì‹  ì„¤ì •
        self.image_sub = self.create_subscription(CompressedImage, '/image_raw/compressed', self.image_callback, 10)
        self.lidar_sub = self.create_subscription(LaserScan, '/scan', self.lidar_callback, qos_profile)
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        
        # ì›¹ ì„œë²„ ì‹œì‘ ë° ì œì–´ ë£¨í”„
        self.start_web_server()
        self.control_timer = self.create_timer(1/20, self.control_loop) # 20Hz
        
        self.get_logger().info('âœ… Autoracer Ultimate Node has been initialized.')
        # ì´ˆê¸°í™” í›„ 1ì´ˆ ë’¤ ì£¼í–‰ ì‹œì‘
        self.create_timer(1.0, self.start_driving, oneshot=True)

    def start_driving(self):
        self.current_mode = DriveMode.LANE_FOLLOWING
        self.get_logger().info('ğŸš€ Starting Lane Following.')

    def setup_bev_transform(self):
        src = np.float32([[200, 300], [440, 300], [0, 460], [640, 460]])
        dst = np.float32([[0, 0], [640, 0], [0, 480], [640, 480]])
        self.bev_matrix = cv2.getPerspectiveTransform(src, dst)
        self.inv_bev_matrix = cv2.getPerspectiveTransform(dst, src)

    def get_ip_address(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except: return "localhost"

    def start_web_server(self):
        def run_server():
            port = 8080
            try:
                server_address = ('0.0.0.0', port)
                httpd = HTTPServer(server_address, lambda *args, **kwargs: WebViewer(self, *args, **kwargs))
                self.get_logger().info(f'ğŸŒ Web server running on http://{self.get_ip_address()}:{port}/')
                httpd.serve_forever()
            except Exception as e:
                self.get_logger().error(f"Web server failed: {e}")

        threading.Thread(target=run_server, daemon=True).start()

    def image_callback(self, msg):
        try:
            np_arr = np.frombuffer(msg.data, np.uint8)
            with self.image_lock:
                self.current_image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
        except Exception as e:
            self.get_logger().error(f'Image callback error: {e}')

    def lidar_callback(self, msg):
        self.lidar_data = np.array(msg.ranges)
    
    def control_loop(self):
        """ë©”ì¸ ì œì–´ ë£¨í”„: ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ ë° ì£¼í–‰ ë¡œì§ ì‹¤í–‰"""
        with self.image_lock:
            if self.current_image is None or self.lidar_data is None:
                self.get_logger().warn('Waiting for sensor data...')
                return
            image = self.current_image.copy()

        # [í•µì‹¬ ë¡œì§] ì¥ì• ë¬¼ ê°ì§€ ë° ëª¨ë“œ ì „í™˜
        obstacle_detected, best_direction = self.check_for_obstacles_lidar()
        
        if self.current_mode == DriveMode.LANE_FOLLOWING and obstacle_detected:
            self.current_mode = DriveMode.OBSTACLE_AVOIDANCE
            self.get_logger().info(f'âš ï¸ Obstacle Detected! Switching to Avoidance. Best direction: {best_direction}')
            self.obstacle_avoidance_timer = time.time()
            self.target_steering = best_direction # íšŒí”¼ ë°©í–¥ìœ¼ë¡œ ì¦‰ì‹œ ì¡°í–¥
            self.target_speed = 0.2 # íšŒí”¼ ì‹œ ê°ì†

        elif self.current_mode == DriveMode.OBSTACLE_AVOIDANCE:
            # ì¥ì• ë¬¼ íšŒí”¼ ê¸°ë™
            self.target_steering = best_direction
            # 2ì´ˆê°„ íšŒí”¼ ê¸°ë™ í›„ ì°¨ì„  ë³µê·€ ì‹œë„
            if time.time() - self.obstacle_avoidance_timer > 2.0 and not obstacle_detected:
                self.get_logger().info('âœ… Obstacle Cleared. Returning to Lane Following.')
                self.current_mode = DriveMode.LANE_FOLLOWING
                self.integral_error = 0 # PID ì ë¶„ê°’ ì´ˆê¸°í™”

        if self.current_mode == DriveMode.LANE_FOLLOWING:
            self.ultimate_lane_follower(image)
        
        # ìµœì¢… í”„ë ˆì„ ë° ì œì–´ ëª…ë ¹ ì—…ë°ì´íŠ¸
        self.processed_frame = image
        self.update_vehicle_control()

    def check_for_obstacles_lidar(self):
        """LiDAR ë°ì´í„°ë¥¼ ì‚¬ìš©í•´ ì „ë°© ì•ˆì „ êµ¬ì—­ ë‚´ ì¥ì• ë¬¼ì„ ê°ì§€í•˜ê³  ìµœì  íšŒí”¼ ê²½ë¡œë¥¼ ì°¾ìŠµë‹ˆë‹¤."""
        if self.lidar_data is None:
            return False, 0.0

        # ë¼ì´ë‹¤ ë°ì´í„°ì—ì„œ ì •ë©´(0ë„)ì„ ì¤‘ì‹¬ìœ¼ë¡œ ì „ë°© 120ë„ ì˜ì—­(-60ë„ ~ +60ë„)ì„ ì¶”ì¶œ
        num_ranges = len(self.lidar_data)
        front_arc_start = (num_ranges * 3) // 4 # -90ë„
        front_arc_end = num_ranges # 0ë„
        left_arc_start = 0 # 0ë„
        left_arc_end = num_ranges // 4 # +90ë„

        # ROS2 turtlebot3 ë¼ì´ë‹¤ëŠ” 0ë„ê°€ ì •ë©´, ì‹œê³„ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ ì¦ê°€
        # ì „ë°© [-60, 60]ë„ ì˜ì—­ì„ ë³´ë ¤ë©´ [0:60] and [300:360]
        front_right = self.lidar_data[300:]
        front_left = self.lidar_data[:60]
        front_view = np.concatenate([front_right, front_left])

        # ì•ˆì „ êµ¬ì—­ ì •ì˜ (í­ 0.4m, ê¸¸ì´ 0.5m)
        safety_distance = 0.5
        
        obstacle_indices = np.where(front_view < safety_distance)[0]
        if not obstacle_indices.any():
            return False, 0.0 # ì¥ì• ë¬¼ ì—†ìŒ

        # ì¥ì• ë¬¼ì´ ê°ì§€ë˜ë©´, ê°€ì¥ ë„“ì€ ê³µê°„ ì°¾ê¸°
        gaps = []
        # ë¼ì´ë‹¤ ë°ì´í„°ë¥¼ 10ë„ì”© 12ê°œì˜ ì„¹í„°ë¡œ ë‚˜ëˆ”
        sector_size = 10
        for i in range(0, 120, sector_size):
            sector = front_view[i : i + sector_size]
            # ìœ íš¨í•œ ê±°ë¦¬ ê°’ë§Œ í•„í„°ë§ (inf, 0 ì œì™¸)
            valid_distances = sector[(sector > 0.1) & ~np.isinf(sector)]
            avg_dist = np.mean(valid_distances) if valid_distances.any() else 5.0 # ì¥ì• ë¬¼ ì—†ìœ¼ë©´ í° ê°’
            gaps.append(avg_dist)
        
        # ê°€ì¥ ë¨¼ í‰ê·  ê±°ë¦¬ë¥¼ ê°€ì§„ ì„¹í„°(ê°€ì¥ ë„“ì€ ê³µê°„)ë¥¼ ì°¾ìŒ
        best_gap_index = np.argmax(gaps)
        
        # í•´ë‹¹ ì„¹í„°ì˜ ì¤‘ì‹¬ ê°ë„ë¥¼ ì¡°í–¥ê°ìœ¼ë¡œ ë³€í™˜ (-60ë„ ~ +60ë„)
        # (best_gap_index * 10 + 5) ëŠ” 5, 15, ..., 115
        # ì¤‘ì‹¬ì—ì„œ 60ë„ ë¹¼ì£¼ë©´ -55, -45, ..., +55
        angle_deg = (best_gap_index * sector_size + sector_size/2) - 60
        # ì¡°í–¥ê°’ìœ¼ë¡œ ë³€í™˜ (ë¼ë””ì•ˆ, ìŠ¤ì¼€ì¼ë§)
        steering_direction = np.clip(math.radians(angle_deg) * -1.5, -0.7, 0.7)

        return True, steering_direction

    def ultimate_lane_follower(self, image):
        """[í•µì‹¬] ê°•í™”ëœ ì°¨ì„  ê°ì§€ ë° ì¶”ì¢… ë¡œì§"""
        bev = cv2.warpPerspective(image, self.bev_matrix, (640, 480))
        
        # 1. ê°•í™”ëœ ì´ë¯¸ì§€ í•„í„°ë§
        gray = cv2.cvtColor(bev, cv2.COLOR_BGR2GRAY)
        # ê·¸ë¦¼ì ì œê±°
        dilated = cv2.dilate(gray, np.ones((7,7), np.uint8))
        median = cv2.medianBlur(dilated, 21)
        diff = 255 - cv2.absdiff(gray, median)
        # í°ìƒ‰ ì°¨ì„  ê°•ì¡°
        normed = cv2.normalize(diff, None, 0, 255, cv2.NORM_MINMAX)
        _, thresh = cv2.threshold(normed, 230, 255, cv2.THRESH_BINARY)
        
        # 2. ì°¨ì„  ì°¾ê¸° ë° ìœ íš¨ì„± ê²€ì¦
        self.left_fit, self.right_fit, success = self.find_lane_lines(thresh)

        if success:
            self.lane_lost_counter = 0
            self.calculate_ultimate_steering(image.shape)
        else:
            self.lane_lost_counter += 1
            if self.lane_lost_counter > 5: # 5í”„ë ˆì„ ì´ìƒ ì‹¤íŒ¨ ì‹œ ê°ì†
                self.target_speed = 0.15
                if self.lane_lost_counter > 20: # 20í”„ë ˆì„ ì´ìƒ ì‹¤íŒ¨ ì‹œ ì •ì§€
                    self.target_speed = 0.0

        # 3. ì‹œê°í™”
        self.draw_lane_and_path(image, bev, thresh)

    def find_lane_lines(self, mask):
        """ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì™€ ì´ì „ í”„ë ˆì„ ì •ë³´ë¥¼ ê²°í•©í•˜ì—¬ ì°¨ì„ ì„ ì°¾ê³  2ì°¨ ë‹¤í•­ì‹ìœ¼ë¡œ í”¼íŒ…"""
        # (ì´ì „ ì½”ë“œì˜ blind_search_lanesì™€ search_around_polyë¥¼ ê²°í•© ë° ê°œì„ )
        height, width = mask.shape
        histogram = np.sum(mask[height//2:, :], axis=0)
        midpoint = width // 2
        
        if self.left_fit is None or self.lane_lost_counter > 5: # ë¸”ë¼ì¸ë“œ ì„œì¹˜
            left_base = np.argmax(histogram[:midpoint])
            right_base = np.argmax(histogram[midpoint:]) + midpoint
        else: # ì´ì „ í”„ë ˆì„ ê¸°ë°˜ ì„œì¹˜
            y_eval = height -1
            left_base = self.left_fit[0]*y_eval**2 + self.left_fit[1]*y_eval + self.left_fit[2]
            right_base = self.right_fit[0]*y_eval**2 + self.right_fit[1]*y_eval + self.right_fit[2]
        
        nwindows, margin, minpix = 9, 80, 40
        window_height = height // nwindows
        nonzero = mask.nonzero()
        nonzeroy, nonzerox = np.array(nonzero[0]), np.array(nonzero[1])
        
        left_lane_inds, right_lane_inds = [], []
        leftx_current, rightx_current = left_base, right_base

        for window in range(nwindows):
            win_y_low, win_y_high = height - (window+1)*window_height, height - window*window_height
            win_xleft_low, win_xleft_high = leftx_current - margin, leftx_current + margin
            win_xright_low, win_xright_high = rightx_current - margin, rightx_current + margin
            
            good_left_inds = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & (nonzerox >= win_xleft_low) & (nonzerox < win_xleft_high)).nonzero()[0]
            good_right_inds = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & (nonzerox >= win_xright_low) & (nonzerox < win_xright_high)).nonzero()[0]
            
            left_lane_inds.append(good_left_inds)
            right_lane_inds.append(good_right_inds)

            if len(good_left_inds) > minpix: leftx_current = int(np.mean(nonzerox[good_left_inds]))
            if len(good_right_inds) > minpix: rightx_current = int(np.mean(nonzerox[good_right_inds]))
        
        leftx, lefty = nonzerox[np.concatenate(left_lane_inds)], nonzeroy[np.concatenate(left_lane_inds)]
        rightx, righty = nonzerox[np.concatenate(right_lane_inds)], nonzeroy[np.concatenate(right_lane_inds)]

        left_fit, right_fit = None, None
        if len(leftx) > 200: left_fit = np.polyfit(lefty, leftx, 2)
        if len(rightx) > 200: right_fit = np.polyfit(righty, rightx, 2)

        # [ìœ íš¨ì„± ê²€ì¦] ì°¨ì„ ì´ í‰í–‰í•˜ê³  ê°„ê²©ì´ ì ì ˆí•œì§€ í™•ì¸
        if left_fit is not None and right_fit is not None:
            # ê³¡ë¥ (2ì°¨í•­ ê³„ìˆ˜)ì´ ë¹„ìŠ·í•œì§€ í™•ì¸
            if abs(left_fit[0] - right_fit[0]) > 0.001: return self.left_fit, self.right_fit, False
            y_eval = height -1
            lane_width = (right_fit[0]*y_eval**2 + right_fit[1]*y_eval + right_fit[2]) - (left_fit[0]*y_eval**2 + left_fit[1]*y_eval + left_fit[2])
            if not (250 < lane_width < 500): return self.left_fit, self.right_fit, False

        return left_fit, right_fit, (left_fit is not None or right_fit is not None)

    def calculate_ultimate_steering(self, shape):
        """[í•µì‹¬] ë¶€ë“œëŸ¬ìš´ ê³¡ì„  ì£¼í–‰ì„ ìœ„í•œ ì˜ˆì¸¡ ì œì–´ ë° PID íŠœë‹"""
        height, width = shape
        y_eval = height * 0.5 # ì˜ˆì¸¡ ì§€ì ì„ ë” ë©€ë¦¬(50%) ì„¤ì •í•˜ì—¬ ë¯¸ë¦¬ ëŒ€ë¹„
        
        if self.left_fit is not None and self.right_fit is not None:
            left_x = self.left_fit[0]*y_eval**2 + self.left_fit[1]*y_eval + self.left_fit[2]
            right_x = self.right_fit[0]*y_eval**2 + self.right_fit[1]*y_eval + self.right_fit[2]
            lane_center = (left_x + right_x) / 2
        elif self.left_fit is not None: lane_center = self.left_fit[0]*y_eval**2 + self.left_fit[1]*y_eval + self.left_fit[2] + 180 # ì°¨ì„ í­ ì˜ˆì¸¡
        elif self.right_fit is not None: lane_center = self.right_fit[0]*y_eval**2 + self.right_fit[1]*y_eval + self.right_fit[2] - 180
        else: return
        
        # PID ì œì–´ (ê²Œì¸ ê°’ ìµœì í™”)
        kp, ki, kd = 0.003, 0.00005, 0.004
        error = lane_center - (width / 2)
        
        p_term = kp * error
        self.integral_error = np.clip(self.integral_error + error, -2000, 2000)
        i_term = ki * self.integral_error
        d_term = kd * (error - self.prev_error)
        self.prev_error = error
        
        steering = p_term + i_term + d_term
        self.target_steering = np.clip(steering, -0.7, 0.7)
        
        # ê³¡ë¥ ì´ ì‹¬í•˜ë©´(ì¡°í–¥ê°ì´ í¬ë©´) ìë™ ê°ì†
        self.target_speed = max(0.2, 0.35 - abs(self.target_steering) * 0.2)
    
    def update_vehicle_control(self):
        """ì°¨ëŸ‰ ì œì–´ ëª…ë ¹ì„ ë¶€ë“œëŸ½ê²Œ ì—…ë°ì´íŠ¸í•˜ì—¬ ë°œí–‰"""
        twist = Twist()
        # ê°€ì†/ì¡°í–¥ì— ê°€ì¤‘ì¹˜ë¥¼ ë‘ì–´ ë¶€ë“œëŸ¬ìš´ ì›€ì§ì„ êµ¬í˜„
        self.current_speed = self.current_speed * 0.8 + self.target_speed * 0.2
        self.current_steering = self.current_steering * 0.7 + self.target_steering * 0.3
        twist.linear.x = self.current_speed
        twist.angular.z = self.current_steering
        self.cmd_pub.publish(twist)

    def draw_lane_and_path(self, image, bev, mask):
        """ì°¨ì„ , ì£¼í–‰ ê²½ë¡œ, ë””ë²„ê·¸ ì •ë³´ë¥¼ ì‹œê°í™”"""
        lane_img = np.zeros_like(bev)
        plot_y = np.linspace(0, bev.shape[0]-1, bev.shape[0])

        if self.left_fit is not None and self.right_fit is not None:
            left_x = self.left_fit[0]*plot_y**2 + self.left_fit[1]*plot_y + self.left_fit[2]
            right_x = self.right_fit[0]*plot_y**2 + self.right_fit[1]*plot_y + self.right_fit[2]
            pts_left = np.array([np.transpose(np.vstack([left_x, plot_y]))])
            pts_right = np.array([np.transpose(np.vstack([right_x, plot_y]))])
            pts = np.hstack((pts_left, pts_right[:, ::-1, :]))
            cv2.fillPoly(lane_img, np.int_([pts]), (0, 255, 0)) # ì£¼í–‰ ê°€ëŠ¥ ì˜ì—­
            
            center_x = (left_x + right_x) / 2
            pts_center = np.array([np.transpose(np.vstack([center_x, plot_y]))])
            cv2.polylines(lane_img, np.int_([pts_center]), False, (255,0,0), 5) # ì£¼í–‰ ê²½ë¡œ

        warped_back = cv2.warpPerspective(lane_img, self.inv_bev_matrix, (image.shape[1], image.shape[0]))
        result = cv2.addWeighted(image, 1, warped_back, 0.4, 0)
        
        # ë””ë²„ê·¸ ì°½ ì¶”ê°€
        debug_window = cv2.resize(cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR), (200, 120))
        cv2.putText(debug_window, "Lane Mask", (10, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,0), 1)
        result[10:130, -210:-10] = debug_window
        np.copyto(image, result)
        
    def draw_status_header(self, image):
        # (ì´ì „ ì½”ë“œì™€ ìœ ì‚¬, í‘œì‹œ ì •ë³´ ì—…ë°ì´íŠ¸)
        pass

    def get_processed_frame(self):
        with self.image_lock:
            return self.processed_frame.copy() if self.processed_frame is not None else None

    def get_stats(self):
        front_dist = "N/A"
        if self.lidar_data is not None:
            # 0ë„ (ì •ë©´) ì£¼ë³€ 5ê°œ ê°’ì˜ í‰ê· ìœ¼ë¡œ ì•ˆì •ì„± í–¥ìƒ
            center_index = 0
            front_scan = self.lidar_data[np.r_[358:360, 0:3]]
            valid_scan = front_scan[front_scan > 0.1]
            if valid_scan.any():
                front_dist = round(float(np.mean(valid_scan)), 2)

        return {
            "Mode": self.current_mode.value,
            "Speed (m/s)": f"{self.current_speed:.2f}",
            "Steering (deg)": f"{math.degrees(self.current_steering):.1f}",
            "LiDAR_Front (m)": front_dist,
            "Lane_Lost_Frames": self.lane_lost_counter,
            "FPS": self.camera_fps
        }

def main(args=None):
    rclpy.init(args=args)
    autoracer_node = Autoracer()
    try:
        rclpy.spin(autoracer_node)
    except KeyboardInterrupt:
        pass
    finally:
        autoracer_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
