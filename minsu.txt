#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy
from sensor_msgs.msg import CompressedImage, LaserScan
from geometry_msgs.msg import Twist
import cv2
import numpy as np
import threading
import time
import socket
import math
from http.server import BaseHTTPRequestHandler, HTTPServer
from enum import Enum
import json

# QoS Configuration
qos_profile = QoSProfile(depth=10)
qos_profile.reliability = ReliabilityPolicy.BEST_EFFORT

class DriveMode(Enum):
    """Mission states for the autonomous racing challenge"""
    TRAFFIC_LIGHT_WAIT = "TRAFFIC_LIGHT"
    RUBBERCON_NAVIGATION = "RUBBERCON"
    LANE_FOLLOWING = "LANE_FOLLOW"
    OBSTACLE_AVOIDANCE = "OBSTACLE_AVOID"
    EMERGENCY_STOP = "E_STOP"
    MISSION_COMPLETE = "COMPLETE"

class ControlParameters:
    """Centralized control parameters for different driving modes"""
    PARAMS = {
        DriveMode.TRAFFIC_LIGHT_WAIT: {
            'kp': 0.0, 'ki': 0.0, 'kd': 0.0,
            'max_speed': 0.0, 'max_steering': 0.0
        },
        DriveMode.RUBBERCON_NAVIGATION: {
            'kp': 0.0035, 'ki': 0.00008, 'kd': 0.002,
            'max_speed': 0.35, 'max_steering': 0.5
        },
        DriveMode.LANE_FOLLOWING: {
            'kp': 0.0028, 'ki': 0.00006, 'kd': 0.002,
            'max_speed': 0.45, 'max_steering': 0.4
        },
        DriveMode.OBSTACLE_AVOIDANCE: {
            'kp': 0.003, 'ki': 0.0001, 'kd': 0.002,
            'max_speed': 0.3, 'max_steering': 0.4
        },
        DriveMode.EMERGENCY_STOP: {
            'kp': 0.0, 'ki': 0.0, 'kd': 0.0,
            'max_speed': 0.0, 'max_steering': 0.0
        }
    }

class WebViewer(BaseHTTPRequestHandler):
    """Web interface for real-time monitoring and debugging"""
    
    def __init__(self, autoracer_node, *args, **kwargs):
        self.autoracer = autoracer_node
        super().__init__(*args, **kwargs)
    
    def log_message(self, format, *args):
        """Suppress default HTTP logging"""
        pass
    
    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(self._generate_html().encode())
            
        elif self.path == '/stream.mjpg':
            self._handle_stream()
            
        elif self.path == '/stats':
            self._handle_stats()
            
        else:
            self.send_error(404)
    
    def _generate_html(self):
        """Generate the monitoring dashboard HTML"""
        return """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Autoracer 2025 - Mission Control</title>
            <style>
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body { 
                    background: linear-gradient(135deg, #0f0f1e, #1a1a2e); 
                    color: #fff; 
                    font-family: 'Inter', system-ui, -apple-system, sans-serif; 
                    padding: 20px;
                }
                .header { text-align: center; padding: 20px 0; background: rgba(255,255,255,0.05); border-radius: 12px; margin-bottom: 20px; }
                h1 { font-size: 2.5em; background: linear-gradient(90deg, #00ff88, #00ccff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
                .container { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; max-width: 1600px; margin: 0 auto; }
                .panel { background: rgba(255,255,255,0.08); border-radius: 16px; padding: 24px; backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.1); }
                .video-container { position: relative; background: #000; border-radius: 12px; overflow: hidden; }
                .video-container img { width: 100%; height: auto; display: block; }
                .mission-indicator { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 20px 0; }
                .mission-card { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; text-align: center; border: 2px solid rgba(255,255,255,0.1); transition: all 0.3s; }
                .mission-card.active { background: rgba(0,255,136,0.2); border-color: #00ff88; transform: scale(1.05); }
                .mission-card.complete { background: rgba(0,200,255,0.2); border-color: #00ccff; }
                .metric-group { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin-bottom: 15px; }
                .metric-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
                .metric-row:last-child { border-bottom: none; }
                .metric-label { color: #aaa; font-size: 0.9em; }
                .metric-value { font-weight: 600; color: #00ff88; font-family: 'Courier New', monospace; }
                .alert-box { background: rgba(255,50,50,0.1); border: 1px solid rgba(255,50,50,0.3); border-radius: 8px; padding: 15px; min-height: 60px; }
                .status-indicator { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; animation: pulse 2s infinite; }
                .status-green { background: #00ff88; }
                .status-yellow { background: #ffaa00; }
                .status-red { background: #ff3366; }
                @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
                .progress-bar { width: 100%; height: 30px; background: rgba(255,255,255,0.1); border-radius: 15px; overflow: hidden; margin: 20px 0; }
                .progress-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #00ccff); transition: width 0.5s ease; display: flex; align-items: center; justify-content: center; font-weight: bold; }
            </style>
        </head>
        <body>
            <div class="header"><h1>AUTORACER 2025 MISSION CONTROL</h1><p style="color: #888; margin-top: 10px;">Real-time Autonomous Vehicle Monitoring System</p></div>
            <div class="mission-indicator">
                <div class="mission-card" id="mission1"> <div style="font-size: 1.5em;">üö¶</div> <div>Mission 1</div> <small>Traffic Light</small> </div>
                <div class="mission-card" id="mission2"> <div style="font-size: 1.5em;">üî∂</div> <div>Mission 2</div> <small>Rubbercons</small> </div>
                <div class="mission-card" id="mission3"> <div style="font-size: 1.5em;">üõ£Ô∏è</div> <div>Mission 3</div> <small>Lane Following</small> </div>
                <div class="mission-card" id="mission4"> <div style="font-size: 1.5em;">üöó</div> <div>Mission 4</div> <small>Obstacle Avoid</small> </div>
            </div>
            <div class="container">
                <div class="panel"><h3 style="margin-bottom: 15px;">üìπ Live Camera Feed</h3><div class="video-container"><img src="/stream.mjpg" alt="Camera Stream"></div><div class="progress-bar"><div id="progress" class="progress-fill" style="width: 0%;"><span id="progress-text">0%</span></div></div></div>
                <div class="panel"><h3 style="margin-bottom: 15px;">üìä System Metrics</h3>
                    <div class="metric-group"><h4 style="margin-bottom: 10px; color: #00ccff;">Vehicle Status</h4><div class="metric-row"><span class="metric-label">Mode</span><span id="mode" class="metric-value">INIT</span></div><div class="metric-row"><span class="metric-label">Speed</span><span id="speed" class="metric-value">0.00 m/s</span></div><div class="metric-row"><span class="metric-label">Steering</span><span id="steering" class="metric-value">0.0¬∞</span></div><div class="metric-row"><span class="metric-label">Runtime</span><span id="runtime" class="metric-value">00:00</span></div></div>
                    <div class="metric-group"><h4 style="margin-bottom: 10px; color: #00ccff;">Detection Status</h4><div class="metric-row"><span class="metric-label">Traffic Light</span><span id="traffic" class="metric-value">SCANNING</span></div><div class="metric-row"><span class="metric-label">Rubbercons</span><span id="rubbercon" class="metric-value">NONE</span></div><div class="metric-row"><span class="metric-label">Lane</span><span id="lane" class="metric-value">NONE</span></div><div class="metric-row"><span class="metric-label">Obstacle</span><span id="obstacle" class="metric-value">CLEAR</span></div></div>
                    <div class="metric-group"><h4 style="margin-bottom: 10px; color: #00ccff;">Sensors</h4><div class="metric-row"><span class="metric-label">Camera FPS</span><span id="fps" class="metric-value">0</span></div><div class="metric-row"><span class="metric-label">LiDAR Range</span><span id="lidar" class="metric-value">N/A</span></div><div class="metric-row"><span class="metric-label">Confidence</span><span id="confidence" class="metric-value">0%</span></div></div>
                    <div class="alert-box"><h4 style="margin-bottom: 10px;">‚ö†Ô∏è System Alerts</h4><div id="alerts"><span class="status-indicator status-green"></span><span>All systems operational</span></div></div>
                </div>
            </div>
            <script>
                let startTime = Date.now();
                function updateDashboard() {
                    fetch('/stats').then(r => r.json()).then(data => {
                        document.getElementById('mode').textContent = data.mode;
                        document.getElementById('speed').textContent = data.speed + ' m/s';
                        document.getElementById('steering').textContent = data.steering + '¬∞';
                        document.getElementById('fps').textContent = data.fps;
                        document.getElementById('lidar').textContent = data.lidar;
                        document.getElementById('confidence').textContent = data.confidence + '%';
                        document.getElementById('traffic').textContent = data.traffic_status;
                        document.getElementById('rubbercon').textContent = data.rubbercon_status;
                        document.getElementById('lane').textContent = data.lane_status;
                        document.getElementById('obstacle').textContent = data.obstacle_status;
                        let elapsed = Math.floor((Date.now() - startTime) / 1000);
                        let mins = Math.floor(elapsed / 60); let secs = elapsed % 60;
                        document.getElementById('runtime').textContent = `${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
                        document.getElementById('progress').style.width = data.progress + '%';
                        document.getElementById('progress-text').textContent = data.progress + '%';
                        for (let i = 1; i <= 4; i++) {
                            let card = document.getElementById('mission' + i);
                            card.className = 'mission-card';
                            if (i < data.current_mission) { card.classList.add('complete'); }
                            if (i === data.current_mission) { card.classList.add('active'); }
                        }
                        let alertsDiv = document.getElementById('alerts');
                        if (data.alerts && data.alerts.length > 0) {
                            alertsDiv.innerHTML = data.alerts.map(alert => {
                                let color = alert.level === 'error' ? 'red' : alert.level === 'warning' ? 'yellow' : 'green';
                                return `<div><span class="status-indicator status-${color}"></span>${alert.message}</div>`;
                            }).join('');
                        } else {
                            alertsDiv.innerHTML = '<span class="status-indicator status-green"></span>All systems operational';
                        }
                    }).catch(e => console.error('Stats error:', e));
                }
                setInterval(updateDashboard, 200);
            </script>
        </body>
        </html>
        """

    def _handle_stream(self):
        self.send_response(200)
        self.send_header('Content-Type', 'multipart/x-mixed-replace; boundary=frame')
        self.end_headers()
        try:
            while True:
                frame = self.autoracer.get_processed_frame()
                if frame is not None:
                    _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 80])
                    self.wfile.write(b'--frame\\r\\n')
                    self.send_header('Content-Type', 'image/jpeg')
                    self.send_header('Content-Length', str(len(buffer)))
                    self.end_headers()
                    self.wfile.write(buffer)
                    self.wfile.write(b'\\r\\n')
                time.sleep(0.033)
        except (BrokenPipeError, ConnectionResetError):
            pass

    def _handle_stats(self):
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        stats = self.autoracer.get_stats()
        self.wfile.write(json.dumps(stats).encode())


class Autoracer(Node):
    def __init__(self):
        super().__init__('autoracer_2025_fixed')
        self._init_state_variables()
        self._setup_vision()
        self._setup_ros2()
        self._start_web_server()
        self.get_logger().info('üèÅ Autoracer 2025 (Fixed & Improved) Initialized!')
    
    def _init_state_variables(self):
        self.current_image = None
        self.processed_frame = None
        self.image_lock = threading.Lock()
        self.current_mode = DriveMode.TRAFFIC_LIGHT_WAIT
        self.mission_stage = 0
        self.traffic_light_passed = False
        self.rubbercon_passed = False
        self.obstacle_avoided = False
        self.mission_complete = False
        self.current_speed, self.current_steering = 0.0, 0.0
        self.target_speed, self.target_steering = 0.0, 0.0
        self.pid_integral, self.prev_error = 0.0, 0.0
        self.traffic_light_state = "WAITING"
        self.green_detection_count = 0
        self.lane_center = None
        self.obstacle_position = None
        self.fps, self.frame_count, self.last_fps_time = 0, 0, time.time()
        self.confidence_score = 0.0
        self.lidar_data = None
        self.min_lidar_distance = float('inf')
        self.alerts = []
        ## --- Ï∂îÍ∞ÄÎêú Î∂ÄÎ∂Ñ: Ï∞®ÏÑ† Ï∂îÏ†Å ÏïàÏ†ïÌôî ---
        self.left_fit = None
        self.right_fit = None
        self.lane_lost_counter = 0

    def _setup_vision(self):
        src_pts = np.float32([[200, 300], [440, 300], [0, 460], [640, 460]])
        dst_pts = np.float32([[0, 0], [640, 0], [0, 480], [640, 480]])
        self.bev_matrix = cv2.getPerspectiveTransform(src_pts, dst_pts)
        self.inv_bev_matrix = cv2.getPerspectiveTransform(dst_pts, src_pts)
        self.color_ranges = {
            'green': {'lower': np.array([35, 80, 80]), 'upper': np.array([90, 255, 255])},
            'orange': {'lower': np.array([5, 100, 100]), 'upper': np.array([25, 255, 255])},
        }

    def _setup_ros2(self):
        self.image_sub = self.create_subscription(CompressedImage, '/image_raw/compressed', self.image_callback, 10)
        self.lidar_sub = self.create_subscription(LaserScan, '/scan', self.lidar_callback, qos_profile)
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.control_timer = self.create_timer(0.05, self.control_loop)
    
    def _start_web_server(self):
        def create_handler(*args, **kwargs):
            return WebViewer(self, *args, **kwargs)
        
        def run_server():
            server = HTTPServer(('0.0.0.0', 8080), create_handler)
            self.get_logger().info(f'üì° Web interface: http://{self._get_ip()}:8080')
            server.serve_forever()
        
        server_thread = threading.Thread(target=run_server, daemon=True)
        server_thread.start()
    
    def _get_ip(self):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "localhost"

    def image_callback(self, msg):
        try:
            np_arr = np.frombuffer(msg.data, np.uint8)
            image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
            if image is not None:
                with self.image_lock:
                    self.current_image = image
        except Exception as e:
            self.get_logger().error(f'Image callback error: {e}')

    def lidar_callback(self, msg):
        self.lidar_data = msg.ranges
        valid_ranges = [r for r in msg.ranges if 0.1 < r < 10.0]
        if valid_ranges:
            self.min_lidar_distance = min(valid_ranges)

    def control_loop(self):
        with self.image_lock:
            if self.current_image is None:
                return
            image = self.current_image.copy()

        self.process_mission(image)
        self._add_debug_overlay(image)
        self.processed_frame = image

        cmd = Twist()
        self.current_speed = self.current_speed * 0.8 + self.target_speed * 0.2
        self.current_steering = self.current_steering * 0.7 + self.target_steering * 0.3
        cmd.linear.x = self.current_speed
        cmd.angular.z = self.current_steering
        self.cmd_pub.publish(cmd)

    def process_mission(self, image):
        if self.current_mode == DriveMode.TRAFFIC_LIGHT_WAIT:
            self._process_traffic_light(image)
        elif self.current_mode == DriveMode.RUBBERCON_NAVIGATION:
            self._process_rubbercon(image)
        elif self.current_mode == DriveMode.LANE_FOLLOWING:
            self._process_lane_following(image)
            if not self.obstacle_avoided and self._detect_obstacle_vehicle(image):
                self.current_mode = DriveMode.OBSTACLE_AVOIDANCE
                self.get_logger().info('üöó Obstacle detected - initiating avoidance')
        elif self.current_mode == DriveMode.OBSTACLE_AVOIDANCE:
            self._process_obstacle_avoidance(image)
    
    ## --- üö¶ 1. ÏàòÏ†ïÎêú Ï¥àÎ°ùÎ∂à Í∞êÏßÄ Î°úÏßÅ ---
    def _process_traffic_light(self, image):
        h, w = image.shape[:2]
        roi = image[0:int(h * 0.4), int(w * 0.25):int(w * 0.75)]
        hsv_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
        
        green_mask = cv2.inRange(hsv_roi, self.color_ranges['green']['lower'], self.color_ranges['green']['upper'])
        kernel = np.ones((5, 5), np.uint8)
        green_mask = cv2.morphologyEx(green_mask, cv2.MORPH_OPEN, kernel)
        
        contours, _ = cv2.findContours(green_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        green_detected = False
        for contour in contours:
            area = cv2.contourArea(contour)
            if area > 200:
                perimeter = cv2.arcLength(contour, True)
                if perimeter > 0:
                    circularity = 4 * np.pi * area / (perimeter ** 2)
                    if circularity > 0.65:
                        green_detected = True
                        break
        
        if green_detected:
            self.green_detection_count += 1
            self.traffic_light_state = "GREEN DETECTED"
            if self.green_detection_count > 10:
                self.traffic_light_passed = True
                self.current_mode = DriveMode.RUBBERCON_NAVIGATION
                self.mission_stage = 1
                self.get_logger().info('‚úÖ Mission 1 Complete - Green light passed!')
        else:
            self.green_detection_count = max(0, self.green_detection_count - 1)
            self.traffic_light_state = "WAITING"
        
        self.target_speed, self.target_steering = 0.0, 0.0

    ## --- üõ£Ô∏è 2. ÏàòÏ†ïÎêú Ï∞®ÏÑ† Ï∂îÏ¢Ö Î°úÏßÅ ---
    def _process_lane_following(self, image):
        bev_image = cv2.warpPerspective(image, self.bev_matrix, (image.shape[1], image.shape[0]))
        lane_mask = self._detect_lanes(bev_image)
        success, left_fit, right_fit = self._find_lane_lines_smart(lane_mask)

        if success:
            self.lane_lost_counter = 0
            self.left_fit, self.right_fit = left_fit, right_fit
            
            h, w = image.shape[:2]
            y_eval = h * 0.5
            left_x = left_fit[0]*y_eval**2 + left_fit[1]*y_eval + left_fit[2]
            right_x = right_fit[0]*y_eval**2 + right_fit[1]*y_eval + right_fit[2]
            self.lane_center = (left_x + right_x) / 2
            center_error = self.lane_center - w / 2
            
            self._calculate_pid_control(center_error, DriveMode.LANE_FOLLOWING)
        else:
            self.lane_lost_counter += 1
            self.lane_center = None
            if self.lane_lost_counter > 5:
                # Use previous error to maintain course for a short duration
                self._calculate_pid_control(self.prev_error * 0.5, DriveMode.LANE_FOLLOWING)
                self.target_speed = 0.2
    
        self._draw_lane_overlay(image, bev_image)

    def _detect_lanes(self, bev_image):
        gray = cv2.cvtColor(bev_image, cv2.COLOR_BGR2GRAY)
        # Adaptive thresholding is robust to lighting changes
        adaptive_thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, -5)
        return adaptive_thresh

    def _find_lane_lines_smart(self, lane_mask):
        if self.left_fit is not None and self.right_fit is not None:
            success, left_fit, right_fit = self._search_around_poly(lane_mask)
            if success:
                return True, left_fit, right_fit
        return self._sliding_window_search(lane_mask)

    def _search_around_poly(self, mask):
        h, w = mask.shape
        margin = 60
        nonzero = mask.nonzero()
        nonzeroy, nonzerox = np.array(nonzero[0]), np.array(nonzero[1])
        
        left_lane_inds = ((nonzerox > (self.left_fit[0]*(nonzeroy**2) + self.left_fit[1]*nonzeroy + self.left_fit[2] - margin)) & (nonzerox < (self.left_fit[0]*(nonzeroy**2) + self.left_fit[1]*nonzeroy + self.left_fit[2] + margin)))
        right_lane_inds = ((nonzerox > (self.right_fit[0]*(nonzeroy**2) + self.right_fit[1]*nonzeroy + self.right_fit[2] - margin)) & (nonzerox < (self.right_fit[0]*(nonzeroy**2) + self.right_fit[1]*nonzeroy + self.right_fit[2] + margin)))
        
        leftx, lefty = nonzerox[left_lane_inds], nonzeroy[left_lane_inds]
        rightx, righty = nonzerox[right_lane_inds], nonzeroy[right_lane_inds]

        if len(leftx) < 100 or len(rightx) < 100: return False, None, None
        
        left_fit, right_fit = np.polyfit(lefty, leftx, 2), np.polyfit(righty, rightx, 2)
        if self._validate_lane_fits(left_fit, right_fit, h):
            return True, left_fit, right_fit
        return False, None, None

    def _sliding_window_search(self, mask):
        h, w = mask.shape
        histogram = np.sum(mask[h//2:, :], axis=0)
        midpoint = w // 2
        left_base, right_base = np.argmax(histogram[:midpoint]), np.argmax(histogram[midpoint:]) + midpoint
        
        nwindows, margin, minpix = 9, 80, 50
        window_height = h // nwindows
        nonzero = mask.nonzero()
        nonzeroy, nonzerox = np.array(nonzero[0]), np.array(nonzero[1])
        
        left_lane_inds, right_lane_inds = [], []
        leftx_current, rightx_current = left_base, right_base

        for window in range(nwindows):
            win_y_low, win_y_high = h-(window+1)*window_height, h-window*window_height
            win_xleft_low, win_xleft_high = leftx_current-margin, leftx_current+margin
            win_xright_low, win_xright_high = rightx_current-margin, rightx_current+margin
            good_left_inds = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & (nonzerox >= win_xleft_low) & (nonzerox < win_xleft_high)).nonzero()[0]
            good_right_inds = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & (nonzerox >= win_xright_low) & (nonzerox < win_xright_high)).nonzero()[0]
            left_lane_inds.append(good_left_inds)
            right_lane_inds.append(good_right_inds)
            if len(good_left_inds) > minpix: leftx_current = int(np.mean(nonzerox[good_left_inds]))
            if len(good_right_inds) > minpix: rightx_current = int(np.mean(nonzerox[good_right_inds]))
        
        leftx, lefty = nonzerox[np.concatenate(left_lane_inds)], nonzeroy[np.concatenate(left_lane_inds)]
        rightx, righty = nonzerox[np.concatenate(right_lane_inds)], nonzeroy[np.concatenate(right_lane_inds)]
        left_fit, right_fit = (np.polyfit(lefty, leftx, 2) if len(leftx)>200 else None, np.polyfit(righty, rightx, 2) if len(rightx)>200 else None)
        
        if self._validate_lane_fits(left_fit, right_fit, h):
            return True, left_fit, right_fit
        return False, None, None

    def _validate_lane_fits(self, left_fit, right_fit, height):
        if left_fit is None or right_fit is None: return False
        y_eval = height - 1
        left_x = left_fit[0]*y_eval**2 + left_fit[1]*y_eval + left_fit[2]
        right_x = right_fit[0]*y_eval**2 + right_fit[1]*y_eval + right_fit[2]
        if not (250 < (right_x - left_x) < 500): return False
        if abs(left_fit[0] - right_fit[0]) > 0.0015: return False
        return True

    def _draw_lane_overlay(self, original, bev_image):
        h, w = bev_image.shape[:2]
        overlay = np.zeros_like(bev_image)
        ploty = np.linspace(0, h-1, h)
        if self.left_fit is not None and self.right_fit is not None:
            left_fitx = self.left_fit[0]*ploty**2 + self.left_fit[1]*ploty + self.left_fit[2]
            right_fitx = self.right_fit[0]*ploty**2 + self.right_fit[1]*ploty + self.right_fit[2]
            pts_left = np.array([np.transpose(np.vstack([left_fitx, ploty]))])
            pts_right = np.array([np.flipud(np.transpose(np.vstack([right_fitx, ploty])))])
            pts = np.hstack((pts_left, pts_right))
            cv2.fillPoly(overlay, np.int32([pts]), (0, 100, 0))

        warped_back = cv2.warpPerspective(overlay, self.inv_bev_matrix, (original.shape[1], original.shape[0]))
        result = cv2.addWeighted(original, 1, warped_back, 0.3, 0)
        np.copyto(original, result)

    def _calculate_pid_control(self, error, mode):
        params = ControlParameters.PARAMS[mode]
        dt = 0.05
        self.pid_integral += error * dt
        self.pid_integral = np.clip(self.pid_integral, -1000, 1000)
        derivative = (error - self.prev_error) / dt
        
        output = -(params['kp'] * error + params['ki'] * self.pid_integral + params['kd'] * derivative)
        
        self.target_steering = np.clip(output, -params['max_steering'], params['max_steering'])
        self.target_speed = params['max_speed'] * (1.0 - 0.8 * abs(self.target_steering) / params['max_steering'])
        self.prev_error = error

    # (Ïù¥Ìïò Ìï®ÏàòÎì§ÏùÄ ÏõêÎ≥∏ Íµ¨Ï°∞ Ïú†ÏßÄÎ•º ÏúÑÌï¥ Í∑∏ÎåÄÎ°ú Îë°ÎãàÎã§)
    def _process_rubbercon(self, image): pass
    def _detect_obstacle_vehicle(self, image): return False
    def _process_obstacle_avoidance(self, image): pass
    
    def _add_debug_overlay(self, image):
        h, w = image.shape[:2]
        overlay = np.zeros((100, w, 3), dtype=np.uint8)
        cv2.addWeighted(image[:100, :], 0.3, overlay, 0.7, 0, image[:100, :])
        
        mode_text = f'MODE: {self.current_mode.value}'
        speed_text = f'SPEED: {self.current_speed:.2f} m/s'
        steer_text = f'STEER: {math.degrees(self.current_steering):.1f} deg'
        
        cv2.putText(image, mode_text, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
        cv2.putText(image, f'FPS: {self.fps}', (w - 120, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 1)
        cv2.putText(image, speed_text, (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)
        cv2.putText(image, steer_text, (10, 85), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)

    def get_processed_frame(self):
        with self.image_lock:
            return self.processed_frame.copy() if self.processed_frame is not None else np.zeros((480, 640, 3), dtype=np.uint8)
    
    def get_stats(self):
        # (Ïõπ ÎåÄÏãúÎ≥¥Îìú ÌÜµÍ≥Ñ Ï†ïÎ≥¥Îäî ÏõêÎ≥∏Í≥º ÎèôÏùºÌïòÍ≤å Ïú†ÏßÄ)
        return {
            'mode': self.current_mode.value,
            'speed': f'{self.current_speed:.2f}',
            'steering': f'{math.degrees(self.current_steering):.1f}',
            'fps': self.fps,
            'lidar': f'{self.min_lidar_distance:.2f}m' if self.min_lidar_distance < float('inf') else 'N/A',
            'confidence': 0, 'progress': 0, 'current_mission': 0, 'mission_stage': 0,
            'traffic_status': self.traffic_light_state,
            'rubbercon_status': 'N/A',
            'lane_status': 'TRACKING' if self.lane_center else 'SEARCHING',
            'obstacle_status': 'N/A', 'alerts': []
        }

def main(args=None):
    rclpy.init(args=args)
    try:
        node = Autoracer()
        rclpy.spin(node)
    except KeyboardInterrupt:
        print("\nüèÅ Autoracer 2025 shutdown")
    finally:
        if 'node' in locals():
            node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
